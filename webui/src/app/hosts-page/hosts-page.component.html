<app-breadcrumbs [items]="breadcrumbs">
    <div page-help>
        <p>
            This page displays a list of host reservations in the network. Kea can store host reservations in either a
            configuration file or a database. Reservations are retrieved at regular intervals, which can be configured
            in the Settings panel under the Configuration menu in the top bar. Kea must have the
            <a href="https://kea.readthedocs.io/en/latest/arm/hooks.html#host-cmds-host-commands"
                >host_cmds hook library</a
            >
            loaded to retrieve host reservations stored in a database (MySQL or PostgreSQL).
        </p>
        <p>Kea supports the following host reservation identifier types:</p>
        <ul>
            <li><b>hw-address</b> - MAC address,</li>
            <li><b>client-id</b> - usable in IPv4 only,</li>
            <li><b>duid</b> - typically used in IPv6, although also usable in IPv4 if clients support it,</li>
            <li><b>flex-id</b>, and</li>
            <li><b>circuit-id</b>.</li>
        </ul>
        <p>
            The hosts can be migrated to the host database using the <b>Migrate to Database</b> button. Stork will
            migrate all hosts selected by the current filter (including those on other pages, if there are more hosts
            than fit on a single page). Those that can't be migrated (e.g. because they're already in a database or are
            in conflicted state) will be skipped. After the migration, hosts will be deleted from your configuration
            file and will be kept in the database only.
        </p>
    </div>
</app-breadcrumbs>

<app-tab-view
    #tabView
    routePath="/dhcp/hosts/"
    [entityProvider]="hostProvider"
    [newFormProvider]="hostFormProvider"
    [entityTitleProvider]="hostLabelProvider"
    [tableQueryParamFilters]="{
        subnetId: { type: 'numeric', matchMode: 'equals' },
        keaSubnetId: { type: 'numeric', matchMode: 'equals' },
        appId: { type: 'numeric', matchMode: 'equals' },
        isGlobal: { type: 'boolean', matchMode: 'equals' },
        conflict: { type: 'boolean', matchMode: 'equals' },
        text: { type: 'string', matchMode: 'contains' },
    }"
    [inputTable]="hostsTable()?.table"
    (tabClosed)="onTabClosed($event)"
    entityTypeName="Host"
>
    <ng-template #firstTab>
        <app-hosts-table #hostsTableComponent></app-hosts-table>
    </ng-template>
    <ng-template #entityTab let-host let-onHostEditBegin="beginEntityEditFn">
        <app-host-tab
            [host]="host"
            (hostEditBegin)="onHostEditBegin(host.id)"
            (hostDelete)="tabView.onDeleteEntity(host.id)"
        ></app-host-tab>
    </ng-template>
    <ng-template
        #formTab
        let-host
        let-tabType="tabType"
        let-tabForm="tabForm"
        let-onHostFormDestroy="destroyFormFn"
        let-onHostFormSubmit="submitFormFn"
        let-onHostFormCancel="cancelFormFn"
    >
        @if (tabType === TabType.New) {
            <app-host-form
                [form]="tabForm.formState"
                (formDestroy)="onHostFormDestroy($event, tabType)"
                (formSubmit)="onHostFormSubmit(tabType)"
                (formCancel)="onHostFormCancel(tabType)"
            ></app-host-form>
        } @else if (tabType === TabType.Edit) {
            <app-host-form
                [form]="tabForm.formState"
                [hostId]="host.id"
                (formDestroy)="onHostFormDestroy($event, tabType, host.id)"
                (formSubmit)="onHostFormSubmit(tabType, host.id)"
                (formCancel)="cancelHostUpdateTransaction(host.id, $event); onHostFormCancel(tabType, host.id)"
            ></app-host-form>
        }
    </ng-template>
</app-tab-view>
